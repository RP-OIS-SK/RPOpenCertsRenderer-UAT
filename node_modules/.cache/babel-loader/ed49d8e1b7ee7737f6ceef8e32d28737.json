{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/OpenCerts/opencerts-renderer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/OpenCerts/opencerts-renderer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/OpenCerts/opencerts-renderer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = memberExpressionToFunctions;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar AssignmentMemoiser = /*#__PURE__*/function () {\n  function AssignmentMemoiser() {\n    _classCallCheck(this, AssignmentMemoiser);\n\n    this._map = new WeakMap();\n  }\n\n  _createClass(AssignmentMemoiser, [{\n    key: \"has\",\n    value: function has(key) {\n      return this._map.has(key);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      if (!this.has(key)) return;\n\n      var record = this._map.get(key);\n\n      var value = record.value;\n      record.count--;\n\n      if (record.count === 0) {\n        return t.assignmentExpression(\"=\", value, key);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value, count) {\n      return this._map.set(key, {\n        count: count,\n        value: value\n      });\n    }\n  }]);\n\n  return AssignmentMemoiser;\n}();\n\nfunction toNonOptional(path, base) {\n  var node = path.node;\n\n  if (path.isOptionalMemberExpression()) {\n    return t.memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    var callee = path.get(\"callee\");\n\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      var object = callee.node.object;\n      var context = path.scope.maybeGenerateMemoised(object) || object;\n      callee.get(\"object\").replaceWith(t.assignmentExpression(\"=\", context, object));\n      return t.callExpression(t.memberExpression(base, t.identifier(\"call\")), [context].concat(_toConsumableArray(node.arguments)));\n    }\n\n    return t.callExpression(base, node.arguments);\n  }\n\n  return path.node;\n}\n\nfunction isInDetachedTree(path) {\n  while (path) {\n    if (path.isProgram()) break;\n    var _path = path,\n        parentPath = _path.parentPath,\n        container = _path.container,\n        listKey = _path.listKey;\n    var parentNode = parentPath.node;\n\n    if (listKey) {\n      if (container !== parentNode[listKey]) return true;\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\nvar handle = {\n  memoise: function memoise() {},\n  handle: function handle(member) {\n    var node = member.node,\n        parent = member.parent,\n        parentPath = member.parentPath;\n\n    if (member.isOptionalMemberExpression()) {\n      if (isInDetachedTree(member)) return;\n      var endPath = member.find(function (_ref) {\n        var node = _ref.node,\n            parent = _ref.parent,\n            parentPath = _ref.parentPath;\n\n        if (parentPath.isOptionalMemberExpression()) {\n          return parent.optional || parent.object !== node;\n        }\n\n        if (parentPath.isOptionalCallExpression()) {\n          return node !== member.node && parent.optional || parent.callee !== node;\n        }\n\n        return true;\n      });\n      var rootParentPath = endPath.parentPath;\n\n      if (rootParentPath.isUpdateExpression({\n        argument: node\n      }) || rootParentPath.isAssignmentExpression({\n        left: node\n      })) {\n        throw member.buildCodeFrameError(\"can't handle assignment\");\n      }\n\n      if (rootParentPath.isUnaryExpression({\n        operator: \"delete\"\n      })) {\n        throw member.buildCodeFrameError(\"can't handle delete\");\n      }\n\n      var startingOptional = member;\n\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n\n        throw new Error(\"Internal error: unexpected \".concat(startingOptional.node.type));\n      }\n\n      var scope = member.scope;\n      var startingProp = startingOptional.isOptionalMemberExpression() ? \"object\" : \"callee\";\n      var startingNode = startingOptional.node[startingProp];\n      var baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      var baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;\n      var parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node\n      });\n      var parentIsCall = parentPath.isCallExpression({\n        callee: node\n      });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n\n      if (parentIsOptionalCall) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      var regular = member.node;\n\n      for (var current = member; current !== endPath;) {\n        var _current = current,\n            _parentPath = _current.parentPath;\n\n        if (_parentPath === endPath && parentIsOptionalCall && parent.optional) {\n          regular = _parentPath.node;\n          break;\n        }\n\n        regular = toNonOptional(_parentPath, regular);\n        current = _parentPath;\n      }\n\n      var context;\n      var endParentPath = endPath.parentPath;\n\n      if (t.isMemberExpression(regular) && endParentPath.isOptionalCallExpression({\n        callee: endPath.node,\n        optional: true\n      })) {\n        var _regular = regular,\n            object = _regular.object;\n        context = member.scope.maybeGenerateMemoised(object);\n\n        if (context) {\n          regular.object = t.assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      endPath.replaceWith(t.conditionalExpression(t.logicalExpression(\"||\", t.binaryExpression(\"===\", baseNeedsMemoised ? t.assignmentExpression(\"=\", baseRef, startingNode) : baseRef, t.nullLiteral()), t.binaryExpression(\"===\", t.cloneNode(baseRef), scope.buildUndefinedNode())), scope.buildUndefinedNode(), regular));\n\n      if (context) {\n        var endParent = endParentPath.node;\n        endParentPath.replaceWith(t.optionalCallExpression(t.optionalMemberExpression(endParent.callee, t.identifier(\"call\"), false, true), [context].concat(_toConsumableArray(endParent.arguments)), false));\n      }\n\n      return;\n    }\n\n    if (parentPath.isUpdateExpression({\n      argument: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      var operator = parent.operator,\n          prefix = parent.prefix;\n      this.memoise(member, 2);\n      var value = t.binaryExpression(operator[0], t.unaryExpression(\"+\", this.get(member)), t.numericLiteral(1));\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        var _scope = member.scope;\n\n        var ref = _scope.generateUidIdentifierBasedOnNode(node);\n\n        _scope.push({\n          id: ref\n        });\n\n        value.left = t.assignmentExpression(\"=\", t.cloneNode(ref), value.left);\n        parentPath.replaceWith(t.sequenceExpression([this.set(member, value), t.cloneNode(ref)]));\n      }\n\n      return;\n    }\n\n    if (parentPath.isAssignmentExpression({\n      left: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      var _operator = parent.operator,\n          right = parent.right;\n      var _value = right;\n\n      if (_operator !== \"=\") {\n        this.memoise(member, 2);\n        _value = t.binaryExpression(_operator.slice(0, -1), this.get(member), _value);\n      }\n\n      parentPath.replaceWith(this.set(member, _value));\n      return;\n    }\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      parentPath.replaceWith(this.call(member, parent.arguments));\n      return;\n    }\n\n    if (parentPath.isOptionalCallExpression({\n      callee: node\n    })) {\n      parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n      return;\n    }\n\n    if (parentPath.isForXStatement({\n      left: node\n    }) || parentPath.isObjectProperty({\n      value: node\n    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isObjectProperty({\n      value: parent\n    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    member.replaceWith(this.get(member));\n  }\n};\n\nfunction memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, Object.assign({}, handle, state, {\n    memoiser: new AssignmentMemoiser()\n  }));\n}","map":{"version":3,"sources":["/OpenCerts/opencerts-renderer/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"],"names":["Object","defineProperty","exports","value","default","memberExpressionToFunctions","t","_interopRequireWildcard","require","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","AssignmentMemoiser","_map","record","count","assignmentExpression","toNonOptional","path","base","node","isOptionalMemberExpression","memberExpression","property","computed","isOptionalCallExpression","callee","optional","object","context","scope","maybeGenerateMemoised","replaceWith","callExpression","identifier","arguments","isInDetachedTree","isProgram","parentPath","container","listKey","parentNode","handle","memoise","member","parent","endPath","find","rootParentPath","isUpdateExpression","argument","isAssignmentExpression","left","buildCodeFrameError","isUnaryExpression","operator","startingOptional","Error","type","startingProp","startingNode","baseNeedsMemoised","baseRef","parentIsOptionalCall","parentIsCall","isCallExpression","optionalCall","boundGet","regular","current","endParentPath","isMemberExpression","conditionalExpression","logicalExpression","binaryExpression","nullLiteral","cloneNode","buildUndefinedNode","endParent","optionalCallExpression","optionalMemberExpression","simpleSet","prefix","unaryExpression","numericLiteral","ref","generateUidIdentifierBasedOnNode","push","id","sequenceExpression","right","slice","isForXStatement","isObjectProperty","isObjectPattern","isAssignmentPattern","isArrayPattern","isRestElement","destructureSet","visitor","state","traverse","assign","memoiser"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = memberExpressionToFunctions;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nclass AssignmentMemoiser {\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n\n    const {\n      value\n    } = record;\n    record.count--;\n\n    if (record.count === 0) {\n      return t.assignmentExpression(\"=\", value, key);\n    }\n\n    return value;\n  }\n\n  set(key, value, count) {\n    return this._map.set(key, {\n      count,\n      value\n    });\n  }\n\n}\n\nfunction toNonOptional(path, base) {\n  const {\n    node\n  } = path;\n\n  if (path.isOptionalMemberExpression()) {\n    return t.memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      const {\n        object\n      } = callee.node;\n      const context = path.scope.maybeGenerateMemoised(object) || object;\n      callee.get(\"object\").replaceWith(t.assignmentExpression(\"=\", context, object));\n      return t.callExpression(t.memberExpression(base, t.identifier(\"call\")), [context, ...node.arguments]);\n    }\n\n    return t.callExpression(base, node.arguments);\n  }\n\n  return path.node;\n}\n\nfunction isInDetachedTree(path) {\n  while (path) {\n    if (path.isProgram()) break;\n    const {\n      parentPath,\n      container,\n      listKey\n    } = path;\n    const parentNode = parentPath.node;\n\n    if (listKey) {\n      if (container !== parentNode[listKey]) return true;\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\nconst handle = {\n  memoise() {},\n\n  handle(member) {\n    const {\n      node,\n      parent,\n      parentPath\n    } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      if (isInDetachedTree(member)) return;\n      const endPath = member.find(({\n        node,\n        parent,\n        parentPath\n      }) => {\n        if (parentPath.isOptionalMemberExpression()) {\n          return parent.optional || parent.object !== node;\n        }\n\n        if (parentPath.isOptionalCallExpression()) {\n          return node !== member.node && parent.optional || parent.callee !== node;\n        }\n\n        return true;\n      });\n      const rootParentPath = endPath.parentPath;\n\n      if (rootParentPath.isUpdateExpression({\n        argument: node\n      }) || rootParentPath.isAssignmentExpression({\n        left: node\n      })) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n\n      if (rootParentPath.isUnaryExpression({\n        operator: \"delete\"\n      })) {\n        throw member.buildCodeFrameError(`can't handle delete`);\n      }\n\n      let startingOptional = member;\n\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n\n        throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);\n      }\n\n      const {\n        scope\n      } = member;\n      const startingProp = startingOptional.isOptionalMemberExpression() ? \"object\" : \"callee\";\n      const startingNode = startingOptional.node[startingProp];\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node\n      });\n      const parentIsCall = parentPath.isCallExpression({\n        callee: node\n      });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n\n      if (parentIsOptionalCall) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular = member.node;\n\n      for (let current = member; current !== endPath;) {\n        const {\n          parentPath\n        } = current;\n\n        if (parentPath === endPath && parentIsOptionalCall && parent.optional) {\n          regular = parentPath.node;\n          break;\n        }\n\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context;\n      const endParentPath = endPath.parentPath;\n\n      if (t.isMemberExpression(regular) && endParentPath.isOptionalCallExpression({\n        callee: endPath.node,\n        optional: true\n      })) {\n        const {\n          object\n        } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n\n        if (context) {\n          regular.object = t.assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      endPath.replaceWith(t.conditionalExpression(t.logicalExpression(\"||\", t.binaryExpression(\"===\", baseNeedsMemoised ? t.assignmentExpression(\"=\", baseRef, startingNode) : baseRef, t.nullLiteral()), t.binaryExpression(\"===\", t.cloneNode(baseRef), scope.buildUndefinedNode())), scope.buildUndefinedNode(), regular));\n\n      if (context) {\n        const endParent = endParentPath.node;\n        endParentPath.replaceWith(t.optionalCallExpression(t.optionalMemberExpression(endParent.callee, t.identifier(\"call\"), false, true), [context, ...endParent.arguments], false));\n      }\n\n      return;\n    }\n\n    if (parentPath.isUpdateExpression({\n      argument: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const {\n        operator,\n        prefix\n      } = parent;\n      this.memoise(member, 2);\n      const value = t.binaryExpression(operator[0], t.unaryExpression(\"+\", this.get(member)), t.numericLiteral(1));\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const {\n          scope\n        } = member;\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({\n          id: ref\n        });\n        value.left = t.assignmentExpression(\"=\", t.cloneNode(ref), value.left);\n        parentPath.replaceWith(t.sequenceExpression([this.set(member, value), t.cloneNode(ref)]));\n      }\n\n      return;\n    }\n\n    if (parentPath.isAssignmentExpression({\n      left: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const {\n        operator,\n        right\n      } = parent;\n      let value = right;\n\n      if (operator !== \"=\") {\n        this.memoise(member, 2);\n        value = t.binaryExpression(operator.slice(0, -1), this.get(member), value);\n      }\n\n      parentPath.replaceWith(this.set(member, value));\n      return;\n    }\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      parentPath.replaceWith(this.call(member, parent.arguments));\n      return;\n    }\n\n    if (parentPath.isOptionalCallExpression({\n      callee: node\n    })) {\n      parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n      return;\n    }\n\n    if (parentPath.isForXStatement({\n      left: node\n    }) || parentPath.isObjectProperty({\n      value: node\n    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isObjectProperty({\n      value: parent\n    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    member.replaceWith(this.get(member));\n  }\n\n};\n\nfunction memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, Object.assign({}, handle, state, {\n    memoiser: new AssignmentMemoiser()\n  }));\n}"]},"metadata":{},"sourceType":"script"}