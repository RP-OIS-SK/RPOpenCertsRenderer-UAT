{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/OpenCerts/demo-opencerts-renderer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _slicedToArray = require(\"/OpenCerts/demo-opencerts-renderer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/OpenCerts/demo-opencerts-renderer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/OpenCerts/demo-opencerts-renderer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n    (function() {\\n      throw new Error('\\\"' + '\", \"' + '\\\" is read-only.');\\n    })()\\n  \"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\n\nvar _helperSimpleAccess = _interopRequireDefault(require(\"@babel/helper-simple-access\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction rewriteLiveReferences(programPath, metadata) {\n  var imported = new Map();\n  var exported = new Map();\n\n  var requeueInParent = function requeueInParent(path) {\n    programPath.requeue(path);\n  };\n\n  var _iterator = _createForOfIteratorHelper(metadata.source),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          source = _step$value[0],\n          data = _step$value[1];\n\n      var _iterator3 = _createForOfIteratorHelper(data.imports),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              localName = _step3$value[0],\n              importName = _step3$value[1];\n\n          imported.set(localName, [source, importName, null]);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(data.importsNamespace),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _localName = _step4.value;\n          imported.set(_localName, [source, null, _localName]);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(metadata.local),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _exportMeta;\n\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          local = _step2$value[0],\n          _data = _step2$value[1];\n\n      var exportMeta = exported.get(local);\n\n      if (!exportMeta) {\n        exportMeta = [];\n        exported.set(local, exportMeta);\n      }\n\n      (_exportMeta = exportMeta).push.apply(_exportMeta, _toConsumableArray(_data.names));\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  programPath.traverse(rewriteBindingInitVisitor, {\n    metadata: metadata,\n    requeueInParent: requeueInParent,\n    scope: programPath.scope,\n    exported: exported\n  });\n  (0, _helperSimpleAccess.default)(programPath, new Set([].concat(_toConsumableArray(Array.from(imported.keys())), _toConsumableArray(Array.from(exported.keys())))));\n  programPath.traverse(rewriteReferencesVisitor, {\n    seen: new WeakSet(),\n    metadata: metadata,\n    requeueInParent: requeueInParent,\n    scope: programPath.scope,\n    imported: imported,\n    exported: exported,\n    buildImportReference: function buildImportReference(_ref, identNode) {\n      var _ref2 = _slicedToArray(_ref, 3),\n          source = _ref2[0],\n          importName = _ref2[1],\n          localName = _ref2[2];\n\n      var meta = metadata.source.get(source);\n\n      if (localName) {\n        if (meta.lazy) identNode = t.callExpression(identNode, []);\n        return identNode;\n      }\n\n      var namespace = t.identifier(meta.name);\n      if (meta.lazy) namespace = t.callExpression(namespace, []);\n      return t.memberExpression(namespace, t.identifier(importName));\n    }\n  });\n}\n\nvar rewriteBindingInitVisitor = {\n  Scope: function Scope(path) {\n    path.skip();\n  },\n  ClassDeclaration: function ClassDeclaration(path) {\n    var requeueInParent = this.requeueInParent,\n        exported = this.exported,\n        metadata = this.metadata;\n    var id = path.node.id;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    var localName = id.name;\n    var exportNames = exported.get(localName) || [];\n\n    if (exportNames.length > 0) {\n      var statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n  VariableDeclaration: function VariableDeclaration(path) {\n    var requeueInParent = this.requeueInParent,\n        exported = this.exported,\n        metadata = this.metadata;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(function (localName) {\n      var exportNames = exported.get(localName) || [];\n\n      if (exportNames.length > 0) {\n        var statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n};\n\nvar buildBindingExportAssignmentExpression = function buildBindingExportAssignmentExpression(metadata, exportNames, localExpr) {\n  return (exportNames || []).reduce(function (expr, exportName) {\n    return t.assignmentExpression(\"=\", t.memberExpression(t.identifier(metadata.exportName), t.identifier(exportName)), expr);\n  }, localExpr);\n};\n\nvar buildImportThrow = function buildImportThrow(localName) {\n  return _template.default.expression.ast(_templateObject(), localName);\n};\n\nvar rewriteReferencesVisitor = {\n  ReferencedIdentifier: function ReferencedIdentifier(path) {\n    var seen = this.seen,\n        buildImportReference = this.buildImportReference,\n        scope = this.scope,\n        imported = this.imported,\n        requeueInParent = this.requeueInParent;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    var localName = path.node.name;\n    var localBinding = path.scope.getBinding(localName);\n    var rootBinding = scope.getBinding(localName);\n    if (rootBinding !== localBinding) return;\n    var importData = imported.get(localName);\n\n    if (importData) {\n      var ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && t.isMemberExpression(ref)) {\n        path.replaceWith(t.sequenceExpression([t.numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && t.isMemberExpression(ref)) {\n        var object = ref.object,\n            property = ref.property;\n        path.replaceWith(t.JSXMemberExpression(t.JSXIdentifier(object.name), t.JSXIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n  AssignmentExpression: {\n    exit: function exit(path) {\n      var _this = this;\n\n      var scope = this.scope,\n          seen = this.seen,\n          imported = this.imported,\n          exported = this.exported,\n          requeueInParent = this.requeueInParent,\n          buildImportReference = this.buildImportReference;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      var left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        var localName = left.node.name;\n\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        var exportedNames = exported.get(localName);\n        var importData = imported.get(localName);\n\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          (0, _assert.default)(path.node.operator === \"=\", \"Path was not simplified\");\n          var assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, assignment.left);\n            assignment.right = t.sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));\n          requeueInParent(path);\n        }\n      } else {\n        var ids = left.getOuterBindingIdentifiers();\n        var programScopeIds = Object.keys(ids).filter(function (localName) {\n          return scope.getBinding(localName) === path.scope.getBinding(localName);\n        });\n        var id = programScopeIds.find(function (localName) {\n          return imported.has(localName);\n        });\n\n        if (id) {\n          path.node.right = t.sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n\n        var items = [];\n        programScopeIds.forEach(function (localName) {\n          var exportedNames = exported.get(localName) || [];\n\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(_this.metadata, exportedNames, t.identifier(localName)));\n          }\n        });\n\n        if (items.length > 0) {\n          var node = t.sequenceExpression(items);\n\n          if (path.parentPath.isExpressionStatement()) {\n            node = t.expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          var statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n  },\n  \"ForOfStatement|ForInStatement\": function ForOfStatementForInStatement(path) {\n    var scope = path.scope,\n        node = path.node;\n    var left = node.left;\n    var exported = this.exported,\n        programScope = this.scope;\n\n    if (!t.isVariableDeclaration(left)) {\n      var didTransform = false;\n      var bodyPath = path.get(\"body\");\n      var loopBodyScope = bodyPath.scope;\n\n      for (var _i = 0, _Object$keys = Object.keys(t.getOuterBindingIdentifiers(left)); _i < _Object$keys.length; _i++) {\n        var name = _Object$keys[_i];\n\n        if (exported.get(name) && programScope.getBinding(name) === scope.getBinding(name)) {\n          didTransform = true;\n\n          if (loopBodyScope.hasOwnBinding(name)) {\n            loopBodyScope.rename(name);\n          }\n        }\n      }\n\n      if (!didTransform) {\n        return;\n      }\n\n      var newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      bodyPath.unshiftContainer(\"body\", t.expressionStatement(t.assignmentExpression(\"=\", left, newLoopId)));\n      path.get(\"left\").replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(newLoopId)]));\n      scope.registerDeclaration(path.get(\"left\"));\n    }\n  }\n};","map":{"version":3,"sources":["/OpenCerts/demo-opencerts-renderer/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"],"names":["Object","defineProperty","exports","value","default","rewriteLiveReferences","_assert","_interopRequireDefault","require","t","_interopRequireWildcard","_template","_helperSimpleAccess","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","programPath","metadata","imported","Map","exported","requeueInParent","path","requeue","source","data","imports","localName","importName","importsNamespace","local","exportMeta","push","names","traverse","rewriteBindingInitVisitor","scope","Set","Array","from","keys","rewriteReferencesVisitor","seen","WeakSet","buildImportReference","identNode","meta","lazy","callExpression","namespace","identifier","name","memberExpression","Scope","skip","ClassDeclaration","id","node","Error","exportNames","length","statement","expressionStatement","buildBindingExportAssignmentExpression","_blockHoist","insertAfter","VariableDeclaration","getOuterBindingIdentifiers","forEach","localExpr","reduce","expr","exportName","assignmentExpression","buildImportThrow","expression","ast","ReferencedIdentifier","add","localBinding","getBinding","rootBinding","importData","ref","loc","parentPath","isCallExpression","callee","isOptionalCallExpression","isTaggedTemplateExpression","tag","isMemberExpression","replaceWith","sequenceExpression","numericLiteral","isJSXIdentifier","object","property","JSXMemberExpression","JSXIdentifier","AssignmentExpression","exit","left","isIdentifier","exportedNames","operator","assignment","right","ids","programScopeIds","filter","find","items","isExpressionStatement","programScope","isVariableDeclaration","didTransform","bodyPath","loopBodyScope","hasOwnBinding","rename","newLoopId","generateUidIdentifierBasedOnNode","unshiftContainer","variableDeclaration","variableDeclarator","registerDeclaration"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\n\nvar _helperSimpleAccess = _interopRequireDefault(require(\"@babel/helper-simple-access\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction rewriteLiveReferences(programPath, metadata) {\n  const imported = new Map();\n  const exported = new Map();\n\n  const requeueInParent = path => {\n    programPath.requeue(path);\n  };\n\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n\n    exportMeta.push(...data.names);\n  }\n\n  programPath.traverse(rewriteBindingInitVisitor, {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported\n  });\n  (0, _helperSimpleAccess.default)(programPath, new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]));\n  programPath.traverse(rewriteReferencesVisitor, {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported,\n    exported,\n    buildImportReference: ([source, importName, localName], identNode) => {\n      const meta = metadata.source.get(source);\n\n      if (localName) {\n        if (meta.lazy) identNode = t.callExpression(identNode, []);\n        return identNode;\n      }\n\n      let namespace = t.identifier(meta.name);\n      if (meta.lazy) namespace = t.callExpression(namespace, []);\n      return t.memberExpression(namespace, t.identifier(importName));\n    }\n  });\n}\n\nconst rewriteBindingInitVisitor = {\n  Scope(path) {\n    path.skip();\n  },\n\n  ClassDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    const {\n      id\n    } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n    const exportNames = exported.get(localName) || [];\n\n    if (exportNames.length > 0) {\n      const statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n\n  VariableDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {\n      const exportNames = exported.get(localName) || [];\n\n      if (exportNames.length > 0) {\n        const statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n\n};\n\nconst buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr) => {\n  return (exportNames || []).reduce((expr, exportName) => {\n    return t.assignmentExpression(\"=\", t.memberExpression(t.identifier(metadata.exportName), t.identifier(exportName)), expr);\n  }, localExpr);\n};\n\nconst buildImportThrow = localName => {\n  return _template.default.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\n\nconst rewriteReferencesVisitor = {\n  ReferencedIdentifier(path) {\n    const {\n      seen,\n      buildImportReference,\n      scope,\n      imported,\n      requeueInParent\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const localName = path.node.name;\n    const localBinding = path.scope.getBinding(localName);\n    const rootBinding = scope.getBinding(localName);\n    if (rootBinding !== localBinding) return;\n    const importData = imported.get(localName);\n\n    if (importData) {\n      const ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && t.isMemberExpression(ref)) {\n        path.replaceWith(t.sequenceExpression([t.numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && t.isMemberExpression(ref)) {\n        const {\n          object,\n          property\n        } = ref;\n        path.replaceWith(t.JSXMemberExpression(t.JSXIdentifier(object.name), t.JSXIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference\n      } = this;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        const localName = left.node.name;\n\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          (0, _assert.default)(path.node.operator === \"=\", \"Path was not simplified\");\n          const assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, assignment.left);\n            assignment.right = t.sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));\n          requeueInParent(path);\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(localName => scope.getBinding(localName) === path.scope.getBinding(localName));\n        const id = programScopeIds.find(localName => imported.has(localName));\n\n        if (id) {\n          path.node.right = t.sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n\n        const items = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, t.identifier(localName)));\n          }\n        });\n\n        if (items.length > 0) {\n          let node = t.sequenceExpression(items);\n\n          if (path.parentPath.isExpressionStatement()) {\n            node = t.expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n\n  },\n\n  \"ForOfStatement|ForInStatement\"(path) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      left\n    } = node;\n    const {\n      exported,\n      scope: programScope\n    } = this;\n\n    if (!t.isVariableDeclaration(left)) {\n      let didTransform = false;\n      const bodyPath = path.get(\"body\");\n      const loopBodyScope = bodyPath.scope;\n\n      for (const name of Object.keys(t.getOuterBindingIdentifiers(left))) {\n        if (exported.get(name) && programScope.getBinding(name) === scope.getBinding(name)) {\n          didTransform = true;\n\n          if (loopBodyScope.hasOwnBinding(name)) {\n            loopBodyScope.rename(name);\n          }\n        }\n      }\n\n      if (!didTransform) {\n        return;\n      }\n\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      bodyPath.unshiftContainer(\"body\", t.expressionStatement(t.assignmentExpression(\"=\", left, newLoopId)));\n      path.get(\"left\").replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(newLoopId)]));\n      scope.registerDeclaration(path.get(\"left\"));\n    }\n  }\n\n};"]},"metadata":{},"sourceType":"script"}